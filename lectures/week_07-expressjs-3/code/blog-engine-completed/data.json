{"blog_posts":[{"title":"How To Be A Baller Node.js Developer","slug":"baller-nodejs","tags":["nodejs","technology"],"content":"<p>Whether you use 2 spaces or 4 spaces, there are a few simple things that can make your node.js code easier to read. We&#39;ve been using them in all the hapi modules for over 4 years now to great results. This list is by no means complete but it highlights the most useful elements that will give you immediate value in reducing bugs.</p>\n<h3 id=\"required-modules\">Required modules</h3>\n<p>JavaScript makes it harder than most languages to know where variables are coming from. Variables assigned required modules are particularly important because they represent a singleton object shared with the entire application. There are also globals and module globals, along with function variables and arguments.</p>\n<p>Traditionally, variables starting with an uppercase letter represent a class that must be instantiated using <code>new</code>. This was an important semantic in the early days of JavaScript but at this point, if you don&#39;t know <code>Date</code> requires <code>new Date()</code> you are probably very new. We have adopted Upper Camel Case variable names for all module global variables which are assigned required modules:</p>\n<pre><code class=\"lang-js\">var Hapi = require(&#39;hapi&#39;);\n</code></pre>\n<p>Note that you cannot <code>new Hapi()</code>, only <code>new Hapi.Server()</code>. In this style, the exported object from the modules always exposes an object which contains the API. This means a single function module should still export an object with the single method as an object property:</p>\n<pre><code class=\"lang-js\">exports.add = function (a, b) {\n\n    return a + b;\n};\n</code></pre>\n<p>This makes it trivial to identify which variables in your code represent required modules. The language itself does contain a few uppercase variables but those are well known and should not cause any confusion.</p>\n<h3 id=\"module-classes\">Module classes</h3>\n<p>When a module (any node.js file) contains its own prototype class, that class variable also starts with an uppercase which can cause confusion. However, we do not allow any module global variable except for one: <code>internals</code> (and of course whatever node.js provides).</p>\n<pre><code class=\"lang-js\">var Hapi = require(&#39;hapi&#39;);\n\nvar internals = {};\n\ninternals.Server = function () {\n\n    this.server = new Hapi.Server();\n    this.server.connection();\n};\n\ninternals.server = new internals.Server();\n\n// This is not allowed:\n\nvar server = new internals.Server();\n</code></pre>\n<p>This means that within any function in your code, uppercase variables are either required modules APIs or JavaScript natives. Any <code>internals</code> prefixed variables are module globals which act as a singleton. The rest are either function variables or arguments which are easier to spot because of the smaller scope.</p>\n<p>A note about singletons - I often see bugs caused by developers using a module global variable used by a prototype. For example:</p>\n<pre><code class=\"lang-js\">var internals = {};\n\ninternals.storage = {};\n\nexports.Cache = internals.Cache = function () {\n\n};\n\ninternals.Cache.prototype.get = function (key) {\n\n    return internals.storage[key];\n};\n\ninternals.Cache.prototype.set = function (key, value) {\n\n    return internals.storage[key] = value;\n};\n</code></pre>\n<p>The problem is that multiple instances of the cache will all share the same memory:</p>\n<pre><code class=\"lang-js\">var Cache = require(&#39;./cache&#39;);\n\nvar cache1 = new Cache();\nvar cache2 = new Cache();    // Uses the same memory cache1 uses\n</code></pre>\n<p>By requiring the use of <code>internals</code> as a prefix, this bug becomes obvious to spot. When I code review a pull request, I always search for all the instances of <code>internals</code> to make sure it only holds static configuration and other safe data to share between instances. This is much harder to spot without the prefix.</p>\n<h3 id=\"callback-new-lines\">Callback new lines</h3>\n<p>Understanding your code flow is critical in asynchronous development. Consider this:</p>\n<pre><code class=\"lang-js\">internals.read = function (db, key, callback) {\n    db.get(key, function (err, value, meta) {\n        if (err) {\n            return callback(err);\n        }\n\n        if (meta.age &gt; 10000) {\n            return callback(null, null);\n        }\n\n        return callback(null, value);\n    });\n};\n</code></pre>\n<p>At a quick glance, it is not obvious that the <code>db.get()</code> method is asynchronous. It looks just like any other scope indentation. By adding a new line after every function declaration, we make the callbacks &quot;pop&quot; and much easier to spot:</p>\n<pre><code class=\"lang-js\">internals.read = function (db, key, callback) {\n\n    db.get(key, function (err, value, meta) {\n\n        if (err) {\n            return callback(err);\n        }\n\n        if (meta.age &gt; 10000) {\n            return callback(null, null);\n        }\n\n        return callback(null, value);\n    });\n};\n</code></pre>\n<p>Allowing your eyes to immediately identify those line breaks means you can quickly note where your code switched event loop ticks.</p>\n<h3 id=\"-return-callbacks\"><code>return</code> callbacks</h3>\n<p>You might have noticed that every <code>callback()</code> call is prefixed with <code>return</code>. This is a defensive programming tool. It provides both a visual cue where in the code execution ends and returned up the stack, but also protection against adding code later after that point that can create timing issues, race conditions, or multiple callback calls.</p>\n<p>It is sometimes helpful to add a <code>return</code> when it is not obvious a nested function contains a callback. Consider the example above, it can be made safer with an extra <code>return</code> either in front of the method:</p>\n<pre><code class=\"lang-js\">internals.read = function (db, key, callback) {\n\n    return db.get(key, function (err, value, meta) {\n\n        if (err) {\n            return callback(err);\n        }\n\n        if (meta.age &gt; 10000) {\n            return callback(null, null);\n        }\n\n        return callback(null, value);\n    });\n};\n</code></pre>\n<p>or immediately after (usually with a comment):</p>\n<pre><code class=\"lang-js\">internals.read = function (db, key, callback) {\n\n    db.get(key, function (err, value, meta) {\n\n        if (err) {\n            return callback(err);\n        }\n\n        if (meta.age &gt; 10000) {\n            return callback(null, null);\n        }\n\n        return callback(null, value);\n    });\n\n    return;    // db.get() invokes the callback\n};\n</code></pre>\n<h3 id=\"-callback-vs-next-\"><code>callback</code> vs <code>next</code></h3>\n<p>There are many cases where a callback doesn&#39;t have to be called on the next tick for performance or workflow reasons. However, that can create an unpredictable API where it is not clear in which tick the callback is invoked. To make it explicit, I use <code>callback</code> when it is guaranteed the callback is called on another tick, and <code>next</code> when it can be both. It is a simple naming convention that has made maintaining hapi much simpler over many months.</p>\n<pre><code class=\"lang-js\">exports.a = function (a, b, callback) {\n\n    return process.nextTick(function () {\n\n        return callback(null, a + b);\n    });\n};\n\nexports.b = function (a, b, next) {\n\n    return next(null, a + b);\n};\n</code></pre>\n","preview":"<p>Whether you use 2 spaces or 4 spaces, there are a few simple things that can make your node.js code easier to read. We&#39;ve been using them in all the hapi modules for over 4 years now to great results. This list is by no means complete but it highlights the most useful elements that will give ","time":"March 10th 2017, 12:58 am"}]}